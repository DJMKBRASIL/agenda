Nesse código abaixo adicione as credencias do meu firebase para que eu salve os dados nele, você tem elas ai na sua memoria.





<!DOCTYPE html>

<html lang="pt-BR">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>DJ MK - Agenda Profissional</title>

    <meta name="description" content="Agenda profissional para DJ MK - Gerencie seus eventos, valores e pagamentos">

    

    <!-- Firebase v9+ -->

    <script type="module">

        // Import the functions you need from the SDKs you need

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';

        import { getFirestore, collection, addDoc, updateDoc, deleteDoc, getDocs, doc, query, where } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

        import { getAnalytics } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js';



        // Your web app's Firebase configuration

        const firebaseConfig = {

            apiKey: "AIzaSyD7FwQZspQNYZmNlQv8oNglccBXHmduW5w",

            authDomain: "sistema-do-salao.firebaseapp.com",

            projectId: "sistema-do-salao",

            storageBucket: "sistema-do-salao.firebasestorage.app",

            messagingSenderId: "395887083088",

            appId: "1:395887083088:web:3a41fd836cc59a976ddb55",

            measurementId: "G-1D996M5FKZ"

        };



        // Initialize Firebase

        let app;

        let db;

        let auth;

        let provider;



        try {

            app = initializeApp(firebaseConfig);

            db = getFirestore(app);

            auth = getAuth(app);

            provider = new GoogleAuthProvider();

            provider.addScope('email');

            provider.addScope('profile');

            

            // Configurar configurações de auth

            auth.useDeviceLanguage();

            

            console.log('🔥 Firebase inicializado com sucesso!');

        } catch (error) {

            console.error('❌ Erro ao inicializar Firebase:', error);

        }



        // Firebase Service Class

        class FirebaseService {

            constructor() {

                this.db = db;

                this.auth = auth;

                this.provider = provider;

                this.collection = 'dj-mk-events';

                

                // Verificar se Firebase foi inicializado

                if (!db || !auth) {

                    throw new Error('Firebase não foi inicializado corretamente');

                }

                

                console.log('🔥 Firebase Service criado');

            }



            // Authentication methods

            async signInWithGoogle() {

                try {

                    console.log('🔐 Tentando login com Google...');

                    

                    // Configurar o provider

                    this.provider.setCustomParameters({

                        prompt: 'select_account'

                    });

                    

                    const result = await signInWithPopup(this.auth, this.provider);

                    console.log('✅ Login realizado:', result.user.email);

                    return result.user;

                } catch (error) {

                    console.error('❌ Erro no login:', error.code, error.message);

                    

                    // Mensagens de erro mais amigáveis

                    let errorMessage = 'Erro ao fazer login. ';

                    switch (error.code) {

                        case 'auth/popup-blocked':

                            errorMessage += 'Popup foi bloqueado pelo navegador.';

                            break;

                        case 'auth/popup-closed-by-user':

                            errorMessage += 'Login cancelado pelo usuário.';

                            break;

                        case 'auth/unauthorized-domain':

                            errorMessage += 'Domínio não autorizado.';

                            break;

                        case 'auth/network-request-failed':

                            errorMessage += 'Erro de rede. Verifique sua conexão.';

                            break;

                        default:

                            errorMessage += 'Tente novamente.';

                    }

                    

                    throw new Error(errorMessage);

                }

            }



            async signOut() {

                try {

                    await signOut(this.auth);

                    console.log('✅ Logout realizado');

                } catch (error) {

                    console.error('❌ Erro no logout:', error);

                    throw error;

                }

            }



            onAuthChange(callback) {

                return onAuthStateChanged(this.auth, callback);

            }



            getCurrentUser() {

                return this.auth.currentUser;

            }



            // Firestore methods

            async getAllEvents() {

                try {

                    const user = this.getCurrentUser();

                    if (!user) throw new Error('Usuário não autenticado');



                    const q = query(

                        collection(this.db, this.collection),

                        where('userId', '==', user.uid)

                    );

                    

                    const querySnapshot = await getDocs(q);

                    const events = [];

                    querySnapshot.forEach((doc) => {

                        events.push({ id: doc.id, ...doc.data() });

                    });

                    

                    // Ordenar por data no frontend

                    events.sort((a, b) => new Date(a.date) - new Date(b.date));

                    

                    console.log('📅 Eventos carregados:', events.length);

                    return events;

                } catch (error) {

                    console.error('❌ Erro ao carregar eventos:', error);

                    throw error;

                }

            }



            async addEvent(eventData) {

                try {

                    const user = this.getCurrentUser();

                    if (!user) {

                        throw new Error('Usuário não autenticado');

                    }



                    // Validar dados obrigatórios

                    if (!eventData.date || !eventData.location) {

                        throw new Error('Data e local são obrigatórios');

                    }



                    const dataWithUser = {

                        date: eventData.date,

                        startTime: eventData.startTime || '',

                        endTime: eventData.endTime || '',

                        location: eventData.location,

                        totalValue: Number(eventData.totalValue) || 0,

                        paidValue: Number(eventData.paidValue) || 0,

                        status: eventData.status || 'em aberto',

                        observations: eventData.observations || '',

                        userId: user.uid,

                        createdAt: new Date().toISOString(),

                        updatedAt: new Date().toISOString()

                    };



                    console.log('📝 Adicionando evento:', dataWithUser);

                    const docRef = await addDoc(collection(this.db, this.collection), dataWithUser);

                    console.log('✅ Evento adicionado com ID:', docRef.id);

                    

                    return { id: docRef.id, ...dataWithUser };

                } catch (error) {

                    console.error('❌ Erro detalhado ao adicionar evento:', error);

                    throw error;

                }

            }



            async updateEvent(eventId, eventData) {

                try {

                    const user = this.getCurrentUser();

                    if (!user) {

                        throw new Error('Usuário não autenticado');

                    }



                    const dataWithUpdate = {

                        date: eventData.date,

                        startTime: eventData.startTime || '',

                        endTime: eventData.endTime || '',

                        location: eventData.location,

                        totalValue: Number(eventData.totalValue) || 0,

                        paidValue: Number(eventData.paidValue) || 0,

                        status: eventData.status || 'em aberto',

                        observations: eventData.observations || '',

                        updatedAt: new Date().toISOString()

                    };



                    console.log('📝 Atualizando evento:', eventId, dataWithUpdate);

                    await updateDoc(doc(this.db, this.collection, eventId), dataWithUpdate);

                    console.log('✅ Evento atualizado:', eventId);

                    

                    return { id: eventId, ...dataWithUpdate, userId: user.uid };

                } catch (error) {

                    console.error('❌ Erro detalhado ao atualizar evento:', error);

                    throw error;

                }

            }



            async deleteEvent(eventId) {

                try {

                    const user = this.getCurrentUser();

                    if (!user) throw new Error('Usuário não autenticado');



                    await deleteDoc(doc(this.db, this.collection, eventId));

                    console.log('✅ Evento deletado:', eventId);

                } catch (error) {

                    console.error('❌ Erro ao deletar evento:', error);

                    throw error;

                }

            }



            async clearAllEvents() {

                try {

                    const user = this.getCurrentUser();

                    if (!user) throw new Error('Usuário não autenticado');



                    const q = query(

                        collection(this.db, this.collection),

                        where('userId', '==', user.uid)

                    );

                    

                    const querySnapshot = await getDocs(q);

                    const deletePromises = [];

                    

                    querySnapshot.forEach((document) => {

                        deletePromises.push(deleteDoc(document.ref));

                    });

                    

                    await Promise.all(deletePromises);

                    console.log('🗑️ Todos os eventos deletados');

                } catch (error) {

                    console.error('❌ Erro ao limpar eventos:', error);

                    throw error;

                }

            }

        }



        // Aguardar Firebase carregar antes de criar o service

        let firebaseService;

        

        // Função para inicializar o service após Firebase carregar

        function initializeFirebaseService() {

            try {

                firebaseService = new FirebaseService();

                window.firebaseService = firebaseService;

                console.log('✅ Firebase Service inicializado');

                return true;

            } catch (error) {

                console.error('❌ Erro ao inicializar Firebase Service:', error);

                return false;

            }

        }



        // Tentar inicializar imediatamente

        let serviceReady = initializeFirebaseService();



        // Se não conseguir, tentar novamente após um delay

        if (!serviceReady) {

            setTimeout(() => {

                serviceReady = initializeFirebaseService();

            }, 1000);

        }

    </script>



    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script>

        tailwind.config = {

            theme: {

                extend: {}

            }

        }

    </script>

    <style>

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

        }

        body {

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;

            -webkit-font-smoothing: antialiased;

            -moz-osx-font-smoothing: grayscale;

            background: #000;

        }

        .lucide {

            width: 1em;

            height: 1em;

            stroke: currentColor;

            stroke-width: 2;

            fill: none;

            stroke-linecap: round;

            stroke-linejoin: round;

        }

    </style>

</head>

<body>

    <div id="root"></div>



    <script type="text/babel">

        const { useState, useEffect } = React;



        // Lucide React Icons

        const Calendar = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>

                <line x1="16" y1="2" x2="16" y2="6"/>

                <line x1="8" y1="2" x2="8" y2="6"/>

                <line x1="3" y1="10" x2="21" y2="10"/>

            </svg>

        );



        const Clock = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <circle cx="12" cy="12" r="10"/>

                <polyline points="12,6 12,12 16,14"/>

            </svg>

        );



        const MapPin = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>

                <circle cx="12" cy="10" r="3"/>

            </svg>

        );



        const DollarSign = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <line x1="12" y1="1" x2="12" y2="23"/>

                <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>

            </svg>

        );



        const Plus = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <line x1="12" y1="5" x2="12" y2="19"/>

                <line x1="5" y1="12" x2="19" y2="12"/>

            </svg>

        );



        const Edit3 = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M12 20h9"/>

                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>

            </svg>

        );



        const Save = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>

                <polyline points="17,21 17,13 7,13 7,21"/>

                <polyline points="7,3 7,8 15,8"/>

            </svg>

        );



        const X = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <line x1="18" y1="6" x2="6" y2="18"/>

                <line x1="6" y1="6" x2="18" y2="18"/>

            </svg>

        );



        const CheckCircle = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>

                <polyline points="22,4 12,14.01 9,11.01"/>

            </svg>

        );



        const AlertCircle = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <circle cx="12" cy="12" r="10"/>

                <line x1="12" y1="8" x2="12" y2="12"/>

                <line x1="12" y1="16" x2="12.01" y2="16"/>

            </svg>

        );



        const Circle = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <circle cx="12" cy="12" r="10"/>

            </svg>

        );



        const LogOut = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>

                <polyline points="16,17 21,12 16,7"/>

                <line x1="21" y1="12" x2="9" y2="12"/>

            </svg>

        );



        const User = ({ size = 20, className = "" }) => (

            <svg className={`lucide ${className}`} width={size} height={size} viewBox="0 0 24 24">

                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>

                <circle cx="12" cy="7" r="4"/>

            </svg>

        );



        // Login Component

        function LoginScreen() {

            const [isLoading, setIsLoading] = useState(false);



            const handleGoogleLogin = async () => {

                setIsLoading(true);

                try {

                    if (!window.firebaseService) {

                        throw new Error('Firebase não foi inicializado. Recarregue a página.');

                    }

                    

                    await window.firebaseService.signInWithGoogle();

                } catch (error) {

                    console.error('Erro no login:', error);

                    alert(`Erro: ${error.message}`);

                } finally {

                    setIsLoading(false);

                }

            };



            return (

                <div className="min-h-screen bg-gradient-to-br from-black via-gray-900 to-black flex items-center justify-center p-4">

                    <div className="bg-gradient-to-br from-gray-900 to-black border border-gray-800 rounded-xl p-8 max-w-md w-full shadow-2xl">

                        <div className="text-center">

                            <h1 className="text-5xl font-bold bg-gradient-to-r from-white via-gray-300 to-yellow-500 bg-clip-text text-transparent mb-2">

                                DJ MK

                            </h1>

                            <p className="text-gray-400 text-lg mb-8">Agenda Profissional</p>

                            <div className="w-24 h-1 bg-gradient-to-r from-yellow-500 to-yellow-300 mx-auto mb-8"></div>

                            

                            <div className="mb-6">

                                <User className="text-gray-400 mx-auto mb-4" size={48} />

                                <h2 className="text-white text-xl font-semibold mb-2">Acesso Restrito</h2>

                                <p className="text-gray-400 text-sm">

                                    Faça login com sua conta Google para acessar sua agenda profissional

                                </p>

                            </div>

                            

                            <button

                                onClick={handleGoogleLogin}

                                disabled={isLoading}

                                className="w-full bg-white hover:bg-gray-100 text-gray-800 font-semibold py-4 px-6 rounded-lg transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-3"

                            >

                                {isLoading ? (

                                    <>

                                        <div className="animate-spin w-5 h-5 border-2 border-gray-800 border-t-transparent rounded-full"></div>

                                        Conectando...

                                    </>

                                ) : (

                                    <>

                                        <svg className="w-5 h-5" viewBox="0 0 24 24">

                                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>

                                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>

                                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>

                                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>

                                        </svg>

                                        Entrar com Google

                                    </>

                                )}

                            </button>

                            

                            <p className="text-gray-500 text-xs mt-4">

                                Seus dados ficam seguros e protegidos pelo Firebase

                            </p>

                        </div>

                    </div>

                </div>

            );

        }



        // Main DJ Agenda Component

        function DJAgenda() {

            const [user, setUser] = useState(null);

            const [events, setEvents] = useState([]);

            const [editingEvent, setEditingEvent] = useState(null);

            const [newEvent, setNewEvent] = useState({

                date: '',

                startTime: '',

                endTime: '',

                location: '',

                totalValue: '',

                paidValue: '',

                status: 'em aberto',

                observations: ''

            });

            const [isAddingEvent, setIsAddingEvent] = useState(false);

            const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());

            const [currentYear, setCurrentYear] = useState(new Date().getFullYear());

            const [isLoading, setIsLoading] = useState(true);

            const [saveStatus, setSaveStatus] = useState('saved');

            const [showClearConfirmation, setShowClearConfirmation] = useState(false);



            const statusOptions = ['pago', 'pendente', 'em aberto'];

            const statusColors = {

                'pago': 'text-green-400',

                'pendente': 'text-yellow-400',

                'em aberto': 'text-red-400'

            };



            const statusIcons = {

                'pago': CheckCircle,

                'pendente': AlertCircle,

                'em aberto': Circle

            };



            const monthNames = [

                'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',

                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'

            ];



            useEffect(() => {

                // Aguardar Firebase Service estar pronto

                const checkFirebaseReady = () => {

                    if (!window.firebaseService) {

                        setTimeout(checkFirebaseReady, 500);

                        return;

                    }



                    const unsubscribe = window.firebaseService.onAuthChange((user) => {

                        console.log('👤 Auth state changed:', user ? user.email : 'No user');

                        setUser(user);

                        setIsLoading(false);

                        

                        if (user) {

                            loadEvents();

                        }

                    });



                    return unsubscribe;

                };



                const unsubscribe = checkFirebaseReady();

                

                return () => {

                    if (unsubscribe && typeof unsubscribe === 'function') {

                        unsubscribe();

                    }

                };

            }, []);



            const loadEvents = async () => {

                if (!window.firebaseService) return;

                

                setIsLoading(true);

                try {

                    const eventsData = await window.firebaseService.getAllEvents();

                    setEvents(eventsData);

                } catch (error) {

                    console.error('Error loading events:', error);

                    alert('Erro ao carregar eventos. Tente recarregar a página.');

                } finally {

                    setIsLoading(false);

                }

            };



            const handleLogout = async () => {

                try {

                    await window.firebaseService.signOut();

                } catch (error) {

                    console.error('Erro no logout:', error);

                }

            };



            const calculateRemainingValue = (total, paid) => {

                const totalNum = parseFloat(total) || 0;

                const paidNum = parseFloat(paid) || 0;

                const remaining = totalNum - paidNum;

                return Math.max(0, remaining);

            };



            const formatCurrency = (value) => {

                return new Intl.NumberFormat('pt-BR', {

                    style: 'currency',

                    currency: 'BRL'

                }).format(value || 0);

            };



            const addEvent = async () => {

                if (newEvent.date && newEvent.location) {

                    setSaveStatus('saving');

                    try {

                        const eventData = {

                            ...newEvent,

                            totalValue: parseFloat(newEvent.totalValue) || 0,

                            paidValue: parseFloat(newEvent.paidValue) || 0

                        };

                        

                        const savedEvent = await window.firebaseService.addEvent(eventData);

                        setEvents(prev => [...prev, savedEvent]);

                        

                        setNewEvent({

                            date: '',

                            startTime: '',

                            endTime: '',

                            location: '',

                            totalValue: '',

                            paidValue: '',

                            status: 'em aberto',

                            observations: ''

                        });

                        setIsAddingEvent(false);

                        setSaveStatus('saved');

                        

                        setTimeout(() => setSaveStatus('saved'), 2000);

                    } catch (error) {

                        console.error('Error adding event:', error);

                        setSaveStatus('error');

                        alert('Erro ao adicionar evento. Tente novamente.');

                    }

                }

            };



            const updateEvent = async (id, updatedEvent) => {

                setSaveStatus('saving');

                try {

                    const eventData = {

                        ...updatedEvent,

                        totalValue: parseFloat(updatedEvent.totalValue) || 0,

                        paidValue: parseFloat(updatedEvent.paidValue) || 0

                    };

                    

                    await window.firebaseService.updateEvent(id, eventData);

                    setEvents(events.map(event => 

                        event.id === id ? { ...eventData, id } : event

                    ));

                    setEditingEvent(null);

                    setSaveStatus('saved');

                    

                    setTimeout(() => setSaveStatus('saved'), 2000);

                } catch (error) {

                    console.error('Error updating event:', error);

                    setSaveStatus('error');

                    alert('Erro ao atualizar evento. Tente novamente.');

                }

            };



            const deleteEvent = async (id) => {

                setSaveStatus('saving');

                try {

                    await window.firebaseService.deleteEvent(id);

                    setEvents(events.filter(event => event.id !== id));

                    setSaveStatus('saved');

                    

                    setTimeout(() => setSaveStatus('saved'), 2000);

                } catch (error) {

                    console.error('Error deleting event:', error);

                    setSaveStatus('error');

                    alert('Erro ao excluir evento. Tente novamente.');

                }

            };



            const clearAllData = async () => {

                setSaveStatus('saving');

                try {

                    await window.firebaseService.clearAllEvents();

                    setEvents([]);

                    setShowClearConfirmation(false);

                    setSaveStatus('saved');

                    

                    setTimeout(() => setSaveStatus('saved'), 2000);

                } catch (error) {

                    console.error('Error clearing all data:', error);

                    setSaveStatus('error');

                    alert('Erro ao limpar agenda. Tente novamente.');

                }

            };



            const getEventsForMonth = () => {

                return events.filter(event => {

                    const eventDate = new Date(event.date);

                    return eventDate.getMonth() === currentMonth && eventDate.getFullYear() === currentYear;

                }).sort((a, b) => new Date(a.date) - new Date(b.date));

            };



            const getTotalRevenue = () => {

                return events.reduce((total, event) => {

                    const value = parseFloat(event.totalValue) || 0;

                    return total + value;

                }, 0);

            };



            const getTotalPaid = () => {

                return events.reduce((total, event) => {

                    const value = parseFloat(event.paidValue) || 0;

                    return total + value;

                }, 0);

            };



            const getTotalPending = () => {

                const revenue = getTotalRevenue();

                const paid = getTotalPaid();

                return Math.max(0, revenue - paid);

            };



            if (!user) {

                return <LoginScreen />;

            }



            if (isLoading) {

                return (

                    <div className="min-h-screen bg-gradient-to-br from-black via-gray-900 to-black flex items-center justify-center">

                        <div className="text-center">

                            <div className="animate-spin w-12 h-12 border-4 border-yellow-400 border-t-transparent rounded-full mx-auto mb-4"></div>

                            <h2 className="text-2xl font-bold text-white mb-2">DJ MK</h2>

                            <p className="text-gray-400 mb-2">Carregando agenda...</p>

                        </div>

                    </div>

                );

            }



            const EventRow = ({ event, isEditing }) => {

                const [editData, setEditData] = useState(event);

                const StatusIcon = statusIcons[event.status];



                if (isEditing) {

                    return (

                        <tr className="border-b border-gray-800 bg-gray-900/50">

                            <td className="px-4 py-3">

                                <span className="text-gray-300 text-sm">

                                    {formatCurrency(calculateRemainingValue(editData.totalValue, editData.paidValue))}

                                </span>

                            </td>

         
